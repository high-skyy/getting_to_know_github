# Git 사용과 이해
## Git이란?
### 분산 버전관리 시스템(Distributed Version control Systems - DVCS)

## Git에 대한 이해(도식)
![image](https://user-images.githubusercontent.com/105041834/187136914-cc0e8193-bade-4839-8c87-b54d41b085ec.png)

## Git에 대한 이해(오브젝트 파일 종류)
**1. Blob 파일**
- Hashing 기법(SHA1 / Simple Hashing Algorithm)을 이용하여 Blob파일들의 이름을 얻어내기 때문에, 내용이 같은 파일들은 모두 하나의 Blob 파일로서 저장된다.
(따라서 존재하는 파일들의 내용을 중복 없이 관리할 수 있다.)
> 버전별로 수정사항이 있는 파일이 있고 없는 파일이 있다. 수정사항이 없고 중복되는 파일은 하나로 저장 된다.(포인터로 구현 했기 때문에) 즉, 모든 파일이 처음에는 하나 씩 있지만 수정사항이 생겨 git add를 하게 되면 새로운 Blob 파일이 형성된다.

**2. Commit 파일**
- 하나의 버전이 곧 하나의 Commit 파일을 만드는 것 (Commit 파일은 하나의 Tree 파일을 가리키게 되어 있다.) Commit 파일에는 가리키고 있는 Tree 파일의 주소(이름)와 직전 버전에 해당하는 Commit 파일의 주소(이름)이 기록 된다.
> 바로 직전의 commit 파일의 주소와 Tree 파일의 주소를 가리키고 있기 때문에 변화된 내용에 대한 저장이 이루어진다고 생각하면 될 것 같다.

**3. Tree 파일**
- 커밋 시점의 파일들 각각에 대해 그 파일명과 해당 파일의 내용을 담고 있는 Blob 파일의 주소(이름)이 기록된다.

**4. commit파일이 여러 개일 경우 각 commit 단계의 파일들을 복구하는 방법**(추가사항)
> github에서 History를 누르면 이제 까지 commit한 내용들을 확인할 수 있다. 여기서 commit ID(SHA)를 복사한 뒤 터미널에 아래 명령어를 치면 작업 내용들을 복구 할 수 있다.
```
git reset --hard [commit id]
```

## Git에 대한 이해(저장소)

**1. 로컬 (local) = Working Directory = Working Copy** 
- 위치 : 프로젝트 폴더
- 현재 프로젝트 폴더에 존재하는 파일들 그 자체를 의미한다.
> 나의 저장소를 의미하며 내가 사용하는 작업대를 의미한다. 프로젝트 시작 시 git pull을 통해 받아 온 내용들을 나의 작업대로 옮겨 작업을 진행하면 된다.

**2. 인덱스 (index) = Staging Area = Cache**
- 위치 : 프로젝트 폴더 하위 .git/index 파일
- 커밋이 이뤄질 준비가 된 파일의 내용들이 위치하는 영역, 실제로는 하나의 파일 (.git/index)로서 존재한다. 로컬에 변동 사항이 생겼을 경우, git add 명령어를 수행하면 해당 변동 사항을 인덱스 영역에 반영시킬 수 있다. 참고로, 인덱스 파일 (.git/index)에는 커밋이 이뤄질 준비가 된 파일의 내용들 각각에 대하여 그 파일명과 해당 파일의 내용을 담고 있는 Blob 파일의 주소(이름)이 기록된다.
> 내 변동 사항을 index 파일에 저장할려면 git add 명령어를 사용해야 한다. Tree가 될 준비를 하는 파일들이라고 생각하면 될 것 같다. 이후 commit를 하게 되면 commit 파일과 Tree가 완성된다고 생각하면 될 것 같다.

**3. 저장소 (Repository)**
- 위치 : 프로젝트 폴더 하위 .git/objects/ 폴더
- 깃이 버젼 과리를 하기 위해 필요로 하는 데이터들을 저장하는 곳 (archive라고 생각)이다. 버전 관리를 시작한 시점부터 현재 시점까지 관리해 온 여러 버전들에 해당하는 파일들의 내용이 Blob 파일로서 이곳에 저장되어 있다. 이곳에 저장된 파일들은 특별히 오브젝트 파일이라고 부르며, Blob 파일도 오브젝트 파일의 한 종류이다.
> commit이 이루어진 이후 push를 통해 repository에 저장을 하게 되면 원하는 오브젝트 파일들에 대한 모든 정보들이 Repository에 저장이 된다고 생각하면 된다.

**4. Branch 정확한 설명 (추가사항) **
- (아래 정리)

## 장점
- 협업에서 수정하는 여러 변경사항들을 쉽게 관리 할 수 있다. (버전을 관리함으로 써)
- 인터넷 연결이 되지 않은 곳에서도 개발을 진행 분산 버전관리이기 때문에 중앙 저장소가 삭제되어도 원상복구
(각 협업자들은 원래 소스코드의 내용에서 각자 본인이 바꾼 부분의 버전을 가지고 있다.)
## 주요 명령어를 사용하기 위한 환경 만들기
- Python
Ctrl + Alt + S 를 눌러서 settings -> tools의 terminal로 들어가서 shell path의 경로를 설치한 git 프로그램의 경로로 들어가서 bin 폴더의 bash 경로를 "(해당경로)" --login을 붙여서 설정
> Pycharm환경 내에서 git의 명령어를 사용 가능하게 만든다.
> Repository 만들고 주소 복사해서 만들고 싶은 위치에 만들 수 있음 (명령 프롬프트 창 열어서)
```
C:\>git clone(해당 주소)
```
> Git을 설치했기 때문에 명령 프롬프트 창에서 git 명령어 사용이 가능하다.


## 주요 명령어
- git init
현재 디렉토리에 .git 폴더를 만들어서 이제부터 깃이 버전 관리를 할 수 있게끔 하는 명령어이다.

- git add <파일명>
인덱스의 내용과 비교했을 때 로컬에서 변동된 사항을 인덱스에 반영시키는 명령어이다. 예를 들어 새로 생성된 파일, 혹은 수정/삭제된 기존 파일이 add 명령의 대상이 된다. <파일명> 대신 .기호를 사용하면 로컬의 현재 디렉토리에서 add 명령의 대상이 되는 파일들 전부를 인덱스에 반영한다.
> git add와 같이 git commit을 습관처럼 해 두자.

- git commit -m <메세지>
인덱스의 내용(이제 까지 수정/삭제 아니면 추가 한 파일들이 이제 commit을 기다리고 있는 상태 / 파일과 해당 파일의 주소값)을 바탕으로 새로운 버전(Commit 파일)을 생성하는 명령어이다. 즉 특정 시점에 존재하는 파일들의 정보에 대한 스냅샷을 찍어서 하나의 버전으로서 저장해두겠다는 의미(설명이 너무 좋다.) <메세지>에는 해당 버전에 대한 설명 등을 지정해주자. (이렇게 지정 안 하면 복구할때 힘들것 같다. commit의 의미가 사라져서 짧게라도 기록해 두는 습관을 들이자.)
> commit = 새로운 버전으로 기억하자.

- git status
로컬의 내용과 인덱스의 내용을 비교하여 add 명령의 대상이 되는 파일들의 목록을 표시해주고, 인덱스의 내용과 최신 커밋의 Tree 파일 내용을 비교하여 commit 명령의 대상이 되는 파일들의 목록을 표시해주는 명령어. (commit나 add 전에 한번 확인해주는 작업을 해주는 것도 좋을 것 같다.) (add 대상)이 빨간 글씨로 표시되며 후자(commit 대상)은 녹색 글씨. 만약 로컬의 내용, 인덱스의 내용, 최신 커밋의 Tree 파일 내용이 모두 같다면 "Nothing to commit"을 출력해준다.
> 로컬에서 수정사항이 있는데 아직 add를 안한 파일들은 빨간 글씨로 표시 add는 되어 있는데 commit이 아직 안되어 있는 파일들은 초록색 글씨로 표시된다.

## Git Branch
> 많은 사람들과 작업을 하는 곳에서 보통 사용할 것 같다.
- Branch란 동일한 소스코드를 가지고 아직 여러 사람들이 독립적인 저장소를 사용할 수 있도록 만들어 주는 기능. (나중에 merge를 통해 합친다.) 저장소를 만들면 Git은 바로 'master'라는 이름의 브랜치를 만들어 줍니다.
- 통합 브랜치(Integration Branch)
언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치 (늘 안정적인 상태를 유지). 보통 Topic Branch를 보통 통합 브랜치에서 만들어 낸다.
- 토픽 브랜치 (Topic Branch == Feature Branch)
기능 추가나 버그 수정과 같은 단위 작업을 위한 브랜치. (보통 통합 브랜치에서 만들어 내고 다 수정된 이후에 다시 통합 브랜치에 병합하는 방식)
- 브랜치 전환하기
처음에는 'master' 브랜치가 선택이 되어 있다. 현재 선택된 브랜치가 아닌 다른 브랜치에서 작업하고 싶을 때에는, '체크아웃(checkout)' 명령어를 실행하여 원하는 브랜치로 전환할 수 있다. 체크아웃을 실행하면, 우선 브랜치 안에 있는 마지막 커밋 내용이 작업 트리에 펼쳐진다. 브랜치가 전환 되었으므로 이 후에 실행한 커밋은 전환한 브랜치에 추가된다.
- HEAD
헤드란 현재 사용 중인 브랜치의 선두 부분을 나타내는 이름.
- Merge
여러 개의 브랜치를 하나로 모을 수 있다. main branch에서 새로운 branch를 만들어서 작업한 이후 main branch에 수정사항이 생긴 경우 -> 양쪽의 변경을 가져온 merge commit 실행
![image](https://backlog.com/git-tutorial/kr/img/post/stepup/capture_stepup1_4_3.png)



## References
- [참고](https://yanacoding.tistory.com/4)
- [참고](https://it-eldorado.tistory.com/4)
- [참고](https://backlog.com/git-tutorial/kr/stepup/stepup1_1.html)
